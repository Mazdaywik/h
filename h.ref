**
** Тоне от Саши (исправленная версия)
**
**
** Запуск программы:
**
** refgo имя-программы [width]
**
** где width — ширина картинки (по умолчанию 80 колонок)
**


*
* Знаковая арифметика с фиксированной запятой, совместимая с Рефалом-05.
* Точность вычислений 0,001
*
* t.Number ::= (s.Sign s.Rep)
* s.Sign ::= '+' | '-'
* s.Rep ::= s.NUMBER
*
* s.Rep — число тысячных.
* Знак нуля должен быть '+', т.е. ('-' 0) — недопустимое значение.
*

Rat {
  (s.Num) s.Denom = ('+' </ <* s.Num 1000> s.Denom>);
}

AddF {
  (s.S s.X) (s.S s.Y) = (s.S <+ s.X s.Y>);
  ('+' s.X) ('-' s.Y) = <WrapSign <- s.X s.Y>>;
  ('-' s.X) ('+' s.Y) = <WrapSign <- s.Y s.X>>;

  t.X t.Y e.Numbers = <AddF t.X <AddF t.Y e.Numbers>>;
}

WrapSign {
  '-' s.X = ('-' s.X);
  s.X = ('+' s.X);
}

SubF {
  ('+' s.X) ('+' s.Y) = <WrapSign <- s.X s.Y>>;
  ('+' s.X) ('-' s.Y) = ('+' <+ s.X s.Y>);
  ('-' s.X) ('+' s.Y) = ('-' <+ s.X s.Y>);
  ('-' s.X) ('-' s.Y) = <WrapSign <- s.Y s.X>>;
}

MulF {
  (s.S s.X) (s.S s.Y) = ('+' </ <* s.X s.Y> 1000>);
  (s.a s.X) (s.b s.Y)
    , <* s.X s.Y>
    : {
        0 = ('+' 0);
        s.Mul = ('-' </ s.Mul 1000>);
      };

  t.X t.Y e.Numbers = <MulF t.X <MulF t.Y e.Numbers>>;
}

DivF {
  (s.S s.X) (s.S s.Y) = ('+' </ <* s.X 1000> s.Y>);
  (s.a s.X) (s.b s.Y)
    , </ <* s.X 1000> s.Y>
    : {
        0 = ('+' 0);
        s.Div = ('-' s.Div);
      };
}

CompareF {
  ('+' s.X) ('+' s.Y) = <Compare s.X s.Y>;
  ('+' s.X) ('-' s.Y) = '+';
  ('-' s.X) ('+' s.Y) = '-';
  ('-' s.X) ('-' s.Y) = <Compare s.Y s.X>;
}

Square {
  t.X = <MulF t.X t.X>;
}

AbsSubF {
  t.X t.Y = <AbsF <SubF t.X t.Y>>;
}

AbsF {
  (s.S s.X) = ('+' s.X);
}


*
* Рисовалка векторных фигур
*

Color {
  (s.Shape e.Args) t.X t.Y = <Mu s.Shape e.Args t.X t.Y>;
}

Draw {
  s.Width t.Shape e.ColorTable =
    <Draw-SaveImage
      s.Width
      (<MakeColorTable e.ColorTable>)
      (<DrawLines <- s.Width 1> s.Width t.Shape>)
    >
}

*$FROM Library
*$EXTERN wb

*
* Формат BMP-файла см. в https://ru.wikipedia.org/wiki/BMP
*
Draw-SaveImage {
  s.Width (e.ColorTable) (e.Pixels)
    , <Lenw e.ColorTable> : s.ColorTableLen e.ColorTable
    , <Lenw e.Pixels> : s.PixelsLen e.Pixels
    , 14 : s.FileHeaderLen
    , 12 : s.CoreHeaderLen
    , <+ s.FileHeaderLen s.CoreHeaderLen> : s.AllHeadersLen
    , <+ s.AllHeadersLen s.ColorTableLen> : s.PixelsOffset

    /* BITMAPFILEHEADER */
    , 'BM' : e.bfType
    , <DWORD <+ s.PixelsOffset s.PixelsLen>> : e.bfSize
    , <WORD 0> : e.bfReserved1
    , <WORD 0> : e.bfReserved2
    , <DWORD s.PixelsOffset> : e.bfOffBits
    , e.bfType e.bfSize e.bfReserved1 e.bfReserved2 e.bfOffBits
    : e.BITMAPFILEHEADER

    /* BITMAPCOREHEADER */
    , <DWORD s.CoreHeaderLen> : e.bcSize
    , <WORD s.Width> : e.bcWidth
    , <WORD s.Width> : e.bcHeight
    , <WORD 1> : e.bcPlanes
    , <WORD 8> : e.bcBitCount
    , e.bcSize e.bcWidth e.bcHeight e.bcPlanes e.bcBitCount
    : e.BITMAPCOREHEADER

    = <Open wb 1 'heart-' <Symb s.Width> '.bmp'>
      <Write 1
        <Chr
          e.BITMAPFILEHEADER
          e.BITMAPCOREHEADER
          e.ColorTable
          e.Pixels
        >
      >
      <Close 1>
}

DWORD { s.Number = <WORD <% s.Number 65536>> <WORD </ s.Number 65536>> }
WORD { s.Number = <% s.Number 256> </ s.Number 256> }

MakeColorTable {
  e.ColorTable = <DoMakeColorTable 0 <Ord e.ColorTable>>;
}

DoMakeColorTable {
  256 /* пусто */ = /* пусто */;

  s.ColorId e.Palette-B (s.ColorId s.R s.G s.B) e.Palette-E
    /* структура RGBTRIPLE */
    = s.B s.G s.R
      <DoMakeColorTable <+ s.ColorId 1> e.Palette-B e.Palette-E>;

  s.ColorId e.Palette
    /* Цвет не используется, пустая ячейка таблицы */
    = 0 0 0 <DoMakeColorTable <+ s.ColorId 1> e.Palette>;
}

DrawLines {
  s.TotalLines s.Width t.Shape =
    <DoDrawLines s.TotalLines s.TotalLines s.Width t.Shape>
}

DoDrawLines {
  0 s.TotalLines s.Width t.Shape =
    <DrawLine ('+' 0) s.Width t.Shape>;

  s.Line s.TotalLines s.Width t.Shape =
    <DoDrawLines <Sub s.Line 1> s.TotalLines s.Width t.Shape>
    <DrawLine <Rat (s.Line) s.TotalLines> s.Width t.Shape>
}

DrawLine {
  t.Y s.Width t.Shape = <Pad4 <DoDrawLine t.Y 0 <- s.Width 1> t.Shape>>;
}

/*
  Формат BMP требует, чтобы длины строчек были кратны 4
*/
Pad4 {
  e.Pixels = <Pad4-Lenw <Lenw e.Pixels>>
}

Pad4-Lenw {
  s.Length e.Pixels = e.Pixels <Pad4-MakePad <% s.Length 4>>
}

Pad4-MakePad {
  0 = /* пусто */;
  1 = '\x00\x00\x00';
  2 = '\x00\x00';
  3 = '\x00';
}

DoDrawLine {
  t.Y s.Width s.Width t.Shape = <Color t.Shape ('+' 1000) t.Y>;

  t.Y s.Col s.Width t.Shape =
    <Color t.Shape <Rat (s.Col) s.Width> t.Y>
    <DoDrawLine t.Y <Add s.Col 1> s.Width t.Shape>;
}

*
* Объектно-ориентированные графические примитивы
*
* t.Shape ::= (s.Tag e.Info)
* <Mu s.Tag e.Info t.X t.Y> ::= s.Color
* s.Color ::= s.CHAR
*
* Цвет заливки — символ. Пробел считается «прозрачным» цветом.
*

/*
  Круг

  t.Circle ::= (Circle s.Color t.R t.Cx t.Cy)
  t.R ::= t.Number -- радиус
  t.Cx, t.Cy ::= t.Number -- координаты центра
*/
Circle {
  s.Color t.R t.Cx t.Cy t.X t.Y =
    <Circle-SwCompare
      s.Color
      <CompareF
        <AddF <Square <AbsSubF t.Cx t.X>> <Square <AbsSubF t.Cy t.Y>>>
        <Square t.R>
      >
    >;
}

Circle-SwCompare {
  s.Color '-' = s.Color;
  s.Color '0' = s.Color;
  s.Color s.Other = ' ';
}

/*
  Объединение фигур

  t.Union ::= (Union t.Shape*)
*/
Union {
  t.Shape e.Shapes t.X t.Y =
    <Union-SwShape
      <Color t.Shape t.X t.Y> e.Shapes t.X t.Y
    >;

  /* нет фигур */ t.X t.Y = ' ';
}

Union-SwShape {
  ' ' e.Shapes t.X t.Y = <Union e.Shapes t.X t.Y>;
  s.Color e.Shapes t.X t.Y = s.Color;
}

/*
  Полуплоскость.

  Прямая на плоскости задаётся как A·x+B·y+C=0. Полуплоскость раскрашивает
  плоскость в два цвета: первый цвет, где A·x+B·y+C >= 0, второй — < 0.

  t.Semiplane ::= (Semiplane s.ColorP s.ColorN t.A t.B t.C)

  t.A, t.B, t.C ::= t.Number
  s.ColorP, s.ColorN ::= s.Color
*/
Semiplane {
  s.ColorP s.ColorN t.A t.B t.C  t.X t.Y
    , <AddF <MulF t.A t.X> <MulF t.B t.Y> t.C>
    : {
        ('+' s.N) = s.ColorP;
        ('-' s.N) = s.ColorN;
      };
}

/*
  <CalcSemiplane t.X1 t.Y1 t.X2 t.Y2 s.ColorP s.ColorN> == t.Semiplane

  Строит полуплоскость по вектору (t.X1 t.Y1) - (t.X2 t.Y2).
  Если смотреть по направлению вектора, то первый цвет слева, второй справа.
*/
CalcSemiplane {
  t.X1 t.Y1 t.X2 t.Y2 s.ColorP s.ColorN
* https://ru.wikipedia.org/wiki/Прямая#Уравнение_прямой,_проходящей_
* через_две_заданные_несовпадающие_точки
    = (Semiplane
        s.ColorP s.ColorN
        <SubF t.Y1 t.Y2>
        <SubF t.X2 t.X1>
        <SubF <MulF t.X1 t.Y2> <MulF t.X2 t.Y1>>
      );
}

/*
  Пересечение фигур

  t.Intersect ::= (Intersect s.Color t.Shape*)

  Цвет фигуры пересечения определяется цветом s.Color, не зависит
  от цветов самих фигур.
*/
Intersect {
  s.Color t.Shape e.Shapes t.X t.Y =
    <Intersect-SwShape
      s.Color <Color t.Shape t.X t.Y> e.Shapes t.X t.Y
    >;

  s.Color /* нет фигур */ t.X t.Y = s.Color;
}

Intersect-SwShape {
  s.Color ' ' e.Shapes t.X t.Y = ' ';
  s.Color s.ShapeColor e.Shapes t.X t.Y = <Intersect s.Color e.Shapes t.X t.Y>;
}


*
* Параметры фигуры (их можно менять)
*

R { = ('+' 200) }
H { = ('+' 700) }
D { = ('+' 600) }

C1x { = <SubF ('+' 500) <R>> }
C2x { = <AddF ('+' 500) <R>> }

DX {
  = <DivF
      <MulF ('+' 2000) <D> <D> <R>>
      <AddF <Square <R>> <Square <D>>>
    >
}

DY {
  = <DivF
      <MulF <D> <SubF <Square <D>> <Square <R>>>>
      <AddF <Square <R>> <Square <D>>>
    >;
}

X1 { = <SubF ('+' 500) <DX>> }
X2 { = <AddF ('+' 500) <DX>> }
YH { = <AddF <YL> <DY>> }
YL { = <SubF <H> <D>> }

$ENTRY Go {
  = <Draw
      <Width>
      (Union
        (Circle '@' <R> <C1x> <H>)
        (Circle '@' <R> <C2x> <H>)
        (Intersect
          '@'
          <CalcSemiplane <X1> <YH> ('+' 500) <YL> '+ '>
          <CalcSemiplane ('+' 500) <YL> <X2> <YH> '+ '>
          <CalcSemiplane <X2> <YH> ('+' 500) <H> '+ '>
          <CalcSemiplane <X1> <YH> ('+' 500) <H> ' +'>
        )
      )
      ('@' 255 0 0)
      (' ' 255 255 255)
    >
}

Width {
  = <Width-SwDefined <Numb <Arg 1>>>
}

Width-SwDefined {
  0 = 80;
  s.Width = s.Width;
}
